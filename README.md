# Документация проекта: Иерархическая таблица данных (React SPA)

![Скрин проекта](/screenshot.png)

## Как запустить

```text
    Собрать образ:

    docker build -t react-table-app .

    Запустить контейнер:

    docker run -d -p 8080:80 --name my-table-app react-table-app

    Открыть в браузере: http://localhost:8080
```

## 1. Общее описание

Проект представляет собой SPA (Single Page Application), реализующее сложную таблицу данных с древовидной структурой (Tree Table). Приложение разработано на **React 18** без использования сторонних UI-библиотек (Material UI, AntD и т.д.), все компоненты написаны с нуля с использованием **Tailwind CSS**.

### Ключевые возможности:

- **Иерархия данных:** Отображение вложенных дочерних элементов (раскрывающиеся строки).
- **Сортировка:** Сортировка по колонкам "Email" и "Balance" (с учетом валютного формата). Сортировка работает рекурсивно внутри каждой ветки дерева.
- **Фильтрация:** Фильтрация по статусу (`isActive`).
- **Пагинация:** Постраничная навигация (применяется только к корневым элементам для сохранения логики дерева).
- **URL-синхронизация:** Состояние фильтров, сортировки и пагинации хранится в URL, что позволяет делиться ссылками и использовать кнопки "Назад/Вперед" в браузере.

---

## 2. Стек технологий

- **Core:** React 18 (Hooks, Context API).
- **Styling:** Tailwind CSS.
- **Utils:**
  - `clsx` + `tailwind-merge` (функция `cn`) — для условного объединения CSS классов без конфликтов.
- **State Management:** URL (History API) + React Context.

---

## 3. Архитектура и Паттерны проектирования

В проекте применены современные паттерны React для обеспечения гибкости и чистоты кода.

### 3.1. Compound Components (Составные компоненты)

Компонент таблицы реализован как набор связанных подкомпонентов (`Table.Root`, `Table.Header`, `Table.Row` и т.д.).

- **Зачем:** Это позволяет потребителю компонента (в `DataTable.jsx`) полностью контролировать верстку колонок и порядок элементов, не передавая гигантский массив конфигурации `columns`.
- **Реализация:** Используется `Context API` (`TableContext`) внутри `Table.Root` для передачи состояния (сортировка, пагинация, раскрытые строки) глубоко в подкомпоненты без "prop drilling".

### 3.2. Render Props / Function as Child

Компонент `Table.Body` и `Table.Row` используют паттерн "Function as Child".

- **Зачем:** Это позволяет инкапсулировать логику раскрытия строки (toggle) внутри компонента таблицы, но дать разработчику полный доступ к рендерингу содержимого строки.
- **Пример:**
  ```jsx
  <Table.Row item={item}>
    {({ isExpanded, onToggle }) => (
      // Разработчик сам решает, куда поставить кнопку раскрытия
      <button onClick={onToggle}>{isExpanded ? "-" : "+"}</button>
    )}
  </Table.Row>
  ```

### 3.3. Separation of Concerns (Разделение ответственности)

Логика приложения четко разделена на три слоя:

1.  **State Layer (`hooks/use-table-params.js`):** Управление состоянием через URL.
2.  **Logic Layer (`hooks/use-tree-data.js`):** Трансформация данных (фильтрация, построение дерева, сортировка, пагинация).
3.  **UI Layer (`custom-uikit/table.js`):** Исключительно отображение данных. Компоненты таблицы "глупые" (dumb components) — они не обрабатывают данные, а только получают их через пропсы.

---

## 4. Описание Хуков (Hooks)

### `useTableParams()`

Управляет синхронизацией состояния с адресной строкой браузера.

- Заменяет стандартный `useState` для глобальных фильтров.
- При изменении фильтра обновляет URL (`?page=2&sort=balance&dir=desc`).
- Слушает событие `popstate` для корректной работы кнопок браузера Назад/Вперед.

### `useTreeData(rawData, params, pageSize)`

Основное "ядро" логики. Преобразует "плоский" массив данных с бэкенда (связь через `parentId`) в готовый для рендера список.

**Этапы обработки данных внутри хука:**

1.  **Фильтрация:** Отсеивание элементов по `isActive`.
2.  **Группировка:** Создание Map `nodesByParent` (где ключ — `parentId`, значение — массив детей).
3.  **Поиск корней:** Определение элементов верхнего уровня (у которых `parentId === 0` или родитель скрыт фильтром).
4.  **Сортировка:** Рекурсивная сортировка. Если сортируем по балансу, то сортируются корневые элементы между собой, и дети внутри каждого родителя тоже сортируются между собой.
5.  **Пагинация:** Применяется **только к корневым элементам**. Это стандарт UX для древовидных таблиц (чтобы дети не разрывались между страницами).
6.  **Flattening (Выпрямление):** Преобразование видимой части дерева обратно в плоский список для рендеринга в `<tbody>`. Элементам добавляется свойство `level` для визуального отступа (padding).
    - _Примечание:_ Стандартный метод `.flat()` не использовался, так как важен порядок обхода (Parent -> Child) и вычисление глубины вложенности.

---

## 5. Структура проекта

```text
src/
├── components/
│   ├── custom-uikit/
│   │   └── table.js       # UI-компоненты таблицы (Root, Row, Cell...)
│   └── DataTable.jsx      # Сборка таблицы, соединение UI и Хуков
├── hooks/
│   ├── use-table-params.js # Синхронизация с URL
│   └── use-tree-data.js    # Логика дерева, сортировки и пагинации
├── lib/
│   └── utils.js           # Утилиты (cn, parseCurrency)
├── constants/
│   └── raw-data.js        # Мок-данные
└── App.js                 # Точка входа
```

---

## 6. Особенности реализации UI

- **Table Layout:** Используется `table-layout: fixed`. Это критично для предотвращения "скачков" ширины колонок при смене страницы. Ширина колонок задается явно в заголовках (`w-[25%]`, `w-[100px]`).
- **Вложенность:** Визуализация иерархии реализована через динамический `padding-left` в первой ячейке, зависящий от `item.level`.
  ```jsx
  style={{ paddingLeft: `${item.level * 20}px` }}
  ```
- **Стилизация:** Все стили написаны на Tailwind CSS. Цвета и отступы унифицированы.
